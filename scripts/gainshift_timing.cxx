//Written by:  B. Olaizola

//Date: 2017-08-11

//Root version: 6.08/02

//GRSIsort version: 3.1.3.2

//This script will take a root file that contains TAC histograms for all the posible LaBr-LaBr combination (like the ones generated by the LaBr-timing script), fit them to Gaussian and produce a text file with all the centroids. This will help with the timing gainmatiching of the TACs.

//For the correct functioning of this script, you need a root file containing an energy-gated (for improved precision) TAC spectrum for every LaBr-LaBr combination. The LaBr-timing script already generates such root file, but be sure it is not applying any other offset already to said histograms. This script will print to screen the offset that each LaBr-LaBr combination has, so you can feed it to your sorting script.

//To compile:
//Note: GRSISort looks for .cxx extensions when compiling (for example it looks in the /myAnalysis and /scripts directories)

#include <fstream>
#include <iostream>
#include <iomanip>//to control the number of decimals when printing to scree
using namespace std;

#include "TFile.h"
#include "TH1F.h"
#include "TF1.h"
#include "TMath.h"

using namespace std;


//main program
int main ( int argc, char *argv[] )
{

  //Definitions:
  const char* datafile_path;
  double central_chan=25000.; //This is the channel to which all the LaBr-LaBr-TAC combinations will be gainshifted. I recomend using the middle of the TAC range (25 ns in most cases).
  double_t gainmatch[8][8];
  int fit_min=0;
  int fit_max=50000;
  double  ps_per_chan=10.;//Assuming the original histograms have 1 ps/chan, this is the compression factor. 10 is a reasonable number
  //Get Histogram from rootfile
  TH1D *histo;
  //TF1 *fitfunc = histo->GetFunction("gaus");

  if ( argc != 2 ){ // argc should be 2 for correct execution
    // We print argv[0] assuming it is the program name
    cout<<"usage: "<< argv[0] <<" <filename>\n";
    datafile_path = argv[1];
  }
  else {
    datafile_path = argv[1];
    //std::string datafile = argv[1];
    printf("Reading datafile: %s\n",datafile_path);
  }

  TFile *datafile = TFile::Open(datafile_path);


  std::cout << std::fixed;//This is to fix the number of decimals printed to screen

  datafile->cd();  
  for(int i = 0; i < 8; ++i){
    for(int j = i+1; j < 8; ++j){
      histo = (TH1D*)datafile->Get(Form("TAC_gated_%d_%d",i,j));//Edit this line so the script gets the right histogram
      histo->Rebin(ps_per_chan);//10 ps/chan is more reasonable
      //Fitting range
      fit_min=(histo->GetMean()-5*histo->GetRMS());//fitting range min, set to -3 times the "sigma" of the distribtuion
      fit_max=(histo->GetMean()+5*histo->GetRMS());//fitting range max, set to +3 times the "sigma" of the distribtuion
      //If there is something in the histogram, we fit it
      if(histo->Integral(fit_min/ps_per_chan,fit_max/ps_per_chan)>1.){
	histo->Fit("gaus","Q","",fit_min,fit_max);
	TF1 *fit = histo->GetFunction("gaus");
	gainmatch[i][j] = fit->GetParameter(1);
	//Printing to screen the useful information
	std::cout<<"   TAC_offset["<<i<<"]["<<j<<"] = ("<<setprecision(0)<<central_chan<<".-"<<setprecision(2)<<gainmatch[i][j]<<");"<<std::endl;
      }
      //This checks if the result is a number (if we do not have a LaBr, one of the TAC combinations will be missed and there will be no histogram)
      if ((gainmatch[i][j] != gainmatch[i][j]) | (gainmatch[i][j] < 1.)){//This is based that the compiler should not considered a NaN a number, so it isn't equalt to any float, including itself.
		gainmatch[i][j]=central_chan;
		std::cout<<"   TAC_offset["<<i<<"]["<<j<<"] = ("<<setprecision(0)<<central_chan<<".-"<<setprecision(0)<<gainmatch[i][j]<<".);"<<std::endl;
	}
    }
  }

  return 0;

}
