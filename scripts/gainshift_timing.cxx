//Written by:  B. Olaizola

//Date: 2017-06-12

//Root version: 6.08/02

//GRSIsort version: 3.1.3.2

//This script will take a root file that contains TAC histograms for all the posible LaBr-LaBr combination (like the ones generated by the LaBr-timing script), fit them to Gaussian and produce a text file with all the centroids. This will help with the timing gainmatiching of the TACs.

//For the correct functioning of this script, you need a root file containing an energy-gated (for improved precision) TAC spectrum for every LaBr-LaBr combination. The LaBr-timing script already generates such root file, but be sure it is not applying any other offset already to said histograms. This script will print to screen the offset that each LaBr-LaBr combination has, so you can feed it to your sorting script.

//To compile:
//Note: GRSISort looks for .cxx extensions when compiling (for example it looks in the /myAnalysis and /scripts directories)

#include <fstream>
#include <iostream>
using namespace std;

#include "TFile.h"
#include "TH1F.h"
#include "TF1.h"
#include "TMath.h"

using namespace std;

//Gaussian function
  Double_t gauss(Double_t *t, Double_t *par)
  {
    Double_t fillval ;
    fillval = par[0] * (TMath::Exp(-1/2*pow((t[0]-par[1])/par[2],2)));
    return fillval;
  }

//main program
int main ( int argc, char *argv[] )
{

  //Definitions:
  const char* datafile_path;
  double central_chan=25000.; //This is the channel to which all the LaBr-LaBr-TAC combinations will be gainshifted. I recomend using the middle of the TAC range (25 ns in most cases).
  double_t gainmatch[8][8];
  double fit_min=0.;
  double fit_max=50000.;
  double  ps_per_chan=10.;//Assuming the original histograms have 1 ps/chan, this is the compression factor. 10 is a reasonable number
  //Get Histogram from rootfile
  TH1D *histo;
  //fitting function
  TF1 *fitfunc;


  if ( argc != 2 ){ // argc should be 2 for correct execution
    // We print argv[0] assuming it is the program name
    cout<<"usage: "<< argv[0] <<" <filename>\n";
    datafile_path = argv[1];
  }
  else {
    datafile_path = argv[1];
    //std::string datafile = argv[1];
    printf("Reading datafile: %s\n",datafile_path);
  }

  TFile *datafile = TFile::Open(datafile_path);

  fitfunc = new TF1("fitfunc",gauss,fit_min,fit_max,3);//edit number of parameters (last number)

  datafile->cd();  
  for(int i = 0; i < 8; ++i){
    for(int j = i+1; j < 8; ++j){
      histo = (TH1D*)datafile->Get(Form("TAC_gated_%d_%d",i,j));//Edit this line so the script gets the right histogram
      histo->Rebin(ps_per_chan);//10 ps/chan is more reasonable
      //Fitting parameters
      fit_min=(histo->GetMean()-5*histo->GetRMS())/ps_per_chan;//fitting range min, set to -3 times the "sigma" of the distribtuion
      fit_max=(histo->GetMean()+5*histo->GetRMS())/ps_per_chan;//fitting range max, set to +3 times the "sigma" of the distribtuion
      histo->GetXaxis()->SetRange(fit_min,fit_max);
      fitfunc->SetParameters(50,histo->GetMean(),histo->GetRMS());
      //fitting paramenters-end
      //histo->Fit("fitfunc","LLRQ","",fit_min,fit_max);
      //gainmatch[i][j] = fitfunc->GetParameter(1);
      gainmatch[i][j] = histo->GetMean();
      //This checks if the result is a number (if we do not have a LaBr, one of the TAC combinations will be missed and there will be no histogram)
      if ((gainmatch[i][j] != gainmatch[i][j]) | (gainmatch[i][j] == 0.)){//This is based that the compiler should not considered a NaN a number, so it isn't equalt to any float, including itself.
		gainmatch[i][j]=central_chan;
	}
      //Printing to screen the useful information
      std::cout<<"   TAC_offset["<<i<<"]["<<j<<"] = ("<<central_chan<<".-"<<setprecision(7)<<gainmatch[i][j]<<");"<<std::endl;
    }
  }
}
